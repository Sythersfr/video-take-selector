<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>script2sequence</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            background-attachment: fixed;
            min-height: 100vh;
            padding: 30px 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.98);
            backdrop-filter: blur(10px);
            border-radius: 24px;
            padding: 50px 40px;
            box-shadow: 0 30px 80px rgba(0, 0, 0, 0.3);
        }

        h1 {
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
            font-size: 3.5em;
            font-weight: 700;
            letter-spacing: -0.03em;
        }

        h1 .icon {
            font-size: 0.7em;
        }

        .subtitle {
            text-align: center;
            color: #6b7280;
            margin-bottom: 40px;
            font-size: 1.15em;
            font-weight: 500;
        }

        .icon-small {
            font-size: 0.9em;
        }

        .progress-bar {
            background: linear-gradient(to right, #f3f4f6, #e5e7eb);
            height: 8px;
            border-radius: 20px;
            margin-bottom: 40px;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .progress-fill {
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            height: 100%;
            width: 0%;
            transition: width 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.5);
        }

        .line-info {
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            padding: 35px;
            border-radius: 16px;
            margin-bottom: 35px;
            border-left: 5px solid;
            border-image: linear-gradient(135deg, #667eea 0%, #764ba2 100%) 1;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
        }

        .line-number {
            font-size: 0.8em;
            color: #667eea;
            font-weight: 700;
            margin-bottom: 14px;
            text-transform: uppercase;
            letter-spacing: 0.15em;
        }

        .script-text {
            font-size: 1.45em;
            color: #1f2937;
            font-style: italic;
            line-height: 1.7;
            font-weight: 500;
        }

        .takes-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(380px, 1fr));
            gap: 28px;
            margin-bottom: 40px;
        }

        .take-card {
            background: white;
            border: 2px solid #e5e7eb;
            border-radius: 20px;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .take-card:hover {
            transform: translateY(-8px) scale(1.01);
            box-shadow: 0 20px 40px rgba(102, 126, 234, 0.25);
            border-color: #667eea;
        }

        .take-card.selected {
            border-color: #667eea;
            box-shadow: 0 8px 30px rgba(102, 126, 234, 0.35), 0 0 0 4px rgba(102, 126, 234, 0.1);
            background: linear-gradient(to bottom, #ffffff, #f9fafb);
        }

        .take-card.hovered-for-io {
            border-color: #f59e0b;
            box-shadow: 0 8px 30px rgba(245, 158, 11, 0.25), 0 0 0 3px rgba(245, 158, 11, 0.15);
        }

        .video-container {
            position: relative;
            width: 100%;
            height: 300px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 16px 16px 0 0;
            overflow: hidden;
        }

        .video-container video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: contain;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }

        .video-container:hover video {
            opacity: 0.95;
        }

        .hover-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            height: 4px;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            width: 0;
            pointer-events: none;
            z-index: 5;
            transition: width 0.1s ease;
            box-shadow: 0 0 10px rgba(102, 126, 234, 0.6);
        }

        .trim-controls {
            padding: 25px;
            background: linear-gradient(to bottom, #f9fafb, #ffffff);
            border-top: 2px solid #e5e7eb;
            display: none;
        }

        .take-card.selected .trim-controls {
            display: block;
        }

        .waveform-container {
            position: relative;
            height: 70px;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border-radius: 12px;
            margin: 12px 0 8px 0;
            overflow: hidden;
            box-shadow: inset 0 2px 8px rgba(0, 0, 0, 0.2);
        }

        .waveform-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        .timeline {
            position: relative;
            height: 48px;
            background: linear-gradient(to bottom, #e5e7eb, #d1d5db);
            border-radius: 12px;
            margin: 12px 0;
            overflow: visible;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .timeline-fill {
            position: absolute;
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 12px;
            pointer-events: none;
            opacity: 0.3;
        }

        .trim-marker {
            position: absolute;
            width: 20px;
            height: 58px;
            top: -5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: 3px solid white;
            border-radius: 10px;
            cursor: ew-resize;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
            z-index: 10;
        }

        .trim-marker:hover {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.7);
        }

        .trim-marker.start {
            left: 0;
        }

        .trim-marker.end {
            right: 0;
        }

        .trim-marker::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 4px;
            height: 24px;
            background: white;
            border-radius: 4px;
        }

        .time-display {
            display: flex;
            justify-content: space-between;
            font-size: 0.8em;
            color: #6b7280;
            margin-top: 8px;
            font-weight: 600;
        }

        .trim-info {
            text-align: center;
            font-size: 0.9em;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 12px;
        }

        .trim-actions {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin: 15px 0;
        }

        .trim-btn {
            padding: 12px 24px;
            border: none;
            border-radius: 12px;
            font-size: 0.9em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .trim-btn-play {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .trim-btn-play:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .trim-btn-reset {
            background: #f3f4f6;
            color: #4b5563;
        }

        .trim-btn-reset:hover {
            background: #e5e7eb;
            transform: translateY(-1px);
        }

        .trim-btn-adjust {
            background: white;
            border: 2px solid #e5e7eb;
            color: #667eea;
            padding: 8px 16px;
            font-size: 0.85em;
        }

        .trim-btn-adjust:hover {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: transparent;
            transform: translateY(-1px);
        }

        .quick-adjustments {
            display: flex;
            gap: 5px;
            align-items: center;
            justify-content: center;
            margin: 10px 0;
            flex-wrap: wrap;
        }

        .adjust-label {
            font-size: 0.85em;
            color: #6b7280;
            font-weight: 600;
            margin: 0 8px;
        }

        .keyboard-hints {
            text-align: center;
            padding: 24px;
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            border-radius: 16px;
            margin-top: 30px;
            font-size: 0.9em;
            color: #4b5563;
            border: 2px solid #e5e7eb;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
        }

        .keyboard-hints kbd {
            display: inline-block;
            padding: 6px 12px;
            background: white;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-weight: 700;
            color: #667eea;
            margin: 0 4px;
            font-size: 0.9em;
            box-shadow: 0 2px 4px rgba(102, 126, 234, 0.15);
        }

        .take-info {
            padding: 22px;
        }

        .take-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .video-name {
            font-weight: 700;
            color: #1f2937;
            font-size: 1em;
        }

        .confidence {
            padding: 6px 14px;
            border-radius: 20px;
            font-size: 0.75em;
            font-weight: 700;
            letter-spacing: 0.05em;
            text-transform: uppercase;
        }

        .confidence.high {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(16, 185, 129, 0.3);
        }

        .confidence.medium {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(245, 158, 11, 0.3);
        }

        .confidence.low {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(239, 68, 68, 0.3);
        }

        .preview-text {
            font-size: 0.9em;
            color: #6b7280;
            font-style: italic;
            line-height: 1.6;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        button {
            padding: 14px 32px;
            border: none;
            border-radius: 12px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            letter-spacing: 0.02em;
        }

        .btn-prev {
            background: white;
            color: #4b5563;
            border: 2px solid #e5e7eb;
        }

        .btn-prev:hover:not(:disabled) {
            background: #f9fafb;
            border-color: #667eea;
            color: #667eea;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .btn-next {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
        }

        .btn-next:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.5);
        }

        .btn-skip {
            background: white;
            color: #f59e0b;
            border: 2px solid #f59e0b;
        }

        .btn-skip:hover:not(:disabled) {
            background: #f59e0b;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.3);
        }

        .btn-finish {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .btn-finish:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(16, 185, 129, 0.5);
        }

        .btn-generate {
            background: linear-gradient(135deg, #ec4899 0%, #8b5cf6 100%);
            color: white;
            font-size: 1.15em;
            padding: 18px 48px;
            box-shadow: 0 6px 20px rgba(236, 72, 153, 0.4);
        }

        .btn-generate:hover:not(:disabled) {
            transform: translateY(-3px) scale(1.02);
            box-shadow: 0 10px 30px rgba(236, 72, 153, 0.5);
        }

        .btn-save {
            background: linear-gradient(135deg, #06b6d4 0%, #0891b2 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(6, 182, 212, 0.3);
        }

        .btn-save:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(6, 182, 212, 0.5);
        }

        button:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            padding: 35px;
            margin: 25px 0;
            border-radius: 16px;
            font-size: 1.05em;
            font-weight: 500;
        }

        .status.info {
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
            color: #1e40af;
            border: 2px solid #93c5fd;
        }

        .status.success {
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
            color: #065f46;
            border: 2px solid #6ee7b7;
            box-shadow: 0 4px 16px rgba(16, 185, 129, 0.2);
        }

        .status.error {
            background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%);
            color: #991b1b;
            border: 2px solid #fca5a5;
        }

        .loading {
            text-align: center;
            padding: 80px 40px;
        }

        .spinner {
            border: 4px solid #e5e7eb;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 0.8s linear infinite;
            margin: 0 auto 24px;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .no-matches {
            text-align: center;
            padding: 60px 40px;
            color: #9ca3af;
            font-size: 1.15em;
            background: linear-gradient(135deg, #f9fafb 0%, #f3f4f6 100%);
            border-radius: 16px;
            border: 2px dashed #d1d5db;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>script2sequence</h1>
        <p class="subtitle">Transform your script into a polished video sequence</p>

        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>

        <div id="content">
            <div class="loading">
                <div class="spinner"></div>
                <p>Loading script and videos...</p>
            </div>
        </div>
    </div>

    <script>
        let currentLine = 1;
        let totalLines = 0;
        let selections = {};
        let trimData = {}; // Store {lineNum: {videoName: {start: 0, end: duration}}}
        let hoverPositions = {}; // Track current hover position for each video
        let hoveredCardId = null; // Track which card is currently being hovered

        async function initialize() {
            try {
                const response = await fetch('/api/initialize', { method: 'POST' });
                const data = await response.json();
                totalLines = data.total_lines;
                loadLine(currentLine);
            } catch (error) {
                document.getElementById('content').innerHTML = `
                    <div class="status error">
                        Error initializing: ${error.message}
                    </div>
                `;
            }
        }

        async function loadLine(lineNum) {
            try {
                const response = await fetch(`/api/line/${lineNum}`);
                const data = await response.json();
                
                updateProgress();
                renderLine(data);
            } catch (error) {
                document.getElementById('content').innerHTML = `
                    <div class="status error">
                        Error loading line: ${error.message}
                    </div>
                `;
            }
        }

        function renderLine(data) {
            const content = document.getElementById('content');
            
            if (data.matches.length === 0) {
                content.innerHTML = `
                    <div class="line-info">
                        <div class="line-number">Line ${data.line_number} of ${totalLines}</div>
                        <div class="script-text">"${data.script_line}"</div>
                    </div>
                    <div class="no-matches">
                        <span class="icon-small">üòî</span> No matching videos found for this line.
                    </div>
                    <div class="controls">
                        <button class="btn-prev" onclick="prevLine()" ${currentLine <= 1 ? 'disabled' : ''}>
                            <span class="icon-small">‚Üê</span> Previous
                        </button>
                        <button class="btn-skip" onclick="skipLine()">
                            <span class="icon-small">‚è≠</span> Skip
                        </button>
                        <button class="btn-next" onclick="nextLine()">
                            Next <span class="icon-small">‚Üí</span>
                        </button>
                    </div>
                `;
                return;
            }

            let takesHtml = '';
            data.matches.forEach((match, index) => {
                const confidenceClass = match.score >= 0.8 ? 'high' : match.score >= 0.6 ? 'medium' : 'low';
                const confidenceText = match.score >= 0.8 ? '<span class="icon-small">‚úÖ</span> Excellent' : match.score >= 0.6 ? '<span class="icon-small">‚ö†Ô∏è</span> Good' : '<span class="icon-small">‚ùì</span> Fair';
                const isSelected = selections[data.line_number] === match.video_name;
                const cardId = `card-${data.line_number}-${index}`;
                
                takesHtml += `
                    <div class="take-card ${isSelected ? 'selected' : ''}" id="${cardId}" onclick="selectTake(${data.line_number}, '${match.video_name}', this)">
                        <div class="video-container" 
                             onmouseenter="startHoverPreview('${cardId}')"
                             onmouseleave="stopHoverPreview('${cardId}')"
                             onmousemove="updateHoverPreview(event, '${cardId}')">
                            <video id="video-${cardId}" src="${match.video_url}" preload="metadata" 
                                   onloadedmetadata="initTrimControls('${cardId}', ${data.line_number}, '${match.video_name}')"></video>
                            <div class="hover-indicator" id="hover-${cardId}"></div>
                        </div>
                        <div class="trim-controls" id="trim-${cardId}">
                            <div class="trim-info">
                                <span class="icon-small">‚úÇÔ∏è</span> Drag markers or use buttons to trim
                            </div>
                            
                            <div class="waveform-container">
                                <canvas class="waveform-canvas" id="waveform-${cardId}"></canvas>
                            </div>
                            
                            <div class="timeline" id="timeline-${cardId}">
                                <div class="timeline-fill" id="fill-${cardId}"></div>
                                <div class="trim-marker start" id="start-${cardId}" 
                                     onmousedown="startDrag(event, '${cardId}', 'start')"></div>
                                <div class="trim-marker end" id="end-${cardId}" 
                                     onmousedown="startDrag(event, '${cardId}', 'end')"></div>
                            </div>
                            
                            <div class="time-display" id="time-${cardId}">
                                <span>Start: <strong>0.00s</strong></span>
                                <span>Duration: <strong>0.00s</strong></span>
                                <span>End: <strong>0.00s</strong></span>
                            </div>
                            
                            <div class="quick-adjustments">
                                <span class="adjust-label">Start:</span>
                                <button class="trim-btn trim-btn-adjust" onclick="adjustTrim('${cardId}', 'start', -1)">-1s</button>
                                <button class="trim-btn trim-btn-adjust" onclick="adjustTrim('${cardId}', 'start', -0.1)">-0.1s</button>
                                <button class="trim-btn trim-btn-adjust" onclick="adjustTrim('${cardId}', 'start', 0.1)">+0.1s</button>
                                <button class="trim-btn trim-btn-adjust" onclick="adjustTrim('${cardId}', 'start', 1)">+1s</button>
                                
                                <span class="adjust-label" style="margin-left: 15px;">End:</span>
                                <button class="trim-btn trim-btn-adjust" onclick="adjustTrim('${cardId}', 'end', -1)">-1s</button>
                                <button class="trim-btn trim-btn-adjust" onclick="adjustTrim('${cardId}', 'end', -0.1)">-0.1s</button>
                                <button class="trim-btn trim-btn-adjust" onclick="adjustTrim('${cardId}', 'end', 0.1)">+0.1s</button>
                                <button class="trim-btn trim-btn-adjust" onclick="adjustTrim('${cardId}', 'end', 1)">+1s</button>
                            </div>
                            
                            <div class="trim-actions">
                                <button class="trim-btn trim-btn-play" onclick="playTrimmed('${cardId}')">
                                    <span class="icon-small">‚ñ∂Ô∏è</span> Play Trimmed Clip
                                </button>
                                <button class="trim-btn trim-btn-reset" onclick="resetTrim('${cardId}', ${data.line_number}, '${match.video_name}')">
                                    <span class="icon-small">‚Ü∫</span> Reset
                                </button>
                            </div>
                        </div>
                        <div class="take-info">
                            <div class="take-header">
                                <span class="video-name">${match.video_name}</span>
                                <span class="confidence ${confidenceClass}">${confidenceText} (${Math.round(match.score * 100)}%)</span>
                            </div>
                            <div class="preview-text">"${match.preview}..."</div>
                        </div>
                    </div>
                `;
            });

            const canGenerate = Object.keys(selections).length === totalLines;
            const hasSelections = Object.keys(selections).length > 0;

            content.innerHTML = `
                <div class="line-info">
                    <div class="line-number">Line ${data.line_number} of ${totalLines}</div>
                    <div class="script-text">"${data.script_line}"</div>
                </div>

                <div class="takes-grid">
                    ${takesHtml}
                </div>

                <div class="controls">
                    <button class="btn-prev" onclick="prevLine()" ${currentLine <= 1 ? 'disabled' : ''}>
                        <span class="icon-small">‚Üê</span> Previous
                    </button>
                    <button class="btn-skip" onclick="skipLine()">
                        <span class="icon-small">‚è≠</span> Skip
                    </button>
                    <button class="btn-next" onclick="nextLine()" ${currentLine >= totalLines ? 'disabled' : ''}>
                        Next <span class="icon-small">‚Üí</span>
                    </button>
                </div>

                <div class="keyboard-hints">
                    <strong>üí° Keyboard Shortcuts:</strong> 
                    Hover over videos to preview | 
                    <kbd>I</kbd> Set trim start (hover to select & trim) | 
                    <kbd>O</kbd> Set trim end at playback position | 
                    <kbd>Space</kbd> Play/Pause selected | 
                    <kbd>Enter</kbd> Next line
                </div>

                ${hasSelections ? `
                    <div class="controls" style="margin-top: 20px;">
                        <button class="btn-save" onclick="saveSession()">
                            <span class="icon-small">üíæ</span> Save Session (${Object.keys(selections).length} selected)
                        </button>
                        <button class="btn-finish" onclick="generateVideo()" ${!hasSelections ? 'disabled' : ''}>
                            <span class="icon-small">‚ö°</span> Finish Now
                        </button>
                    </div>
                ` : ''}

                ${canGenerate ? `
                    <div class="status success">
                        <span class="icon-small">üéâ</span> All lines selected! Ready to generate your video.
                    </div>
                    <div class="controls">
                        <button class="btn-save" onclick="saveSession()">
                            <span class="icon-small">üíæ</span> Save Session
                        </button>
                        <button class="btn-generate" onclick="generateVideo()">
                            <span class="icon-small">üé¨</span> Generate Final Video
                        </button>
                    </div>
                ` : ''}
            `;
        }

        function updateProgress() {
            const progress = (Object.keys(selections).length / totalLines) * 100;
            document.getElementById('progressFill').style.width = `${progress}%`;
        }

        function skipLine() {
            // Just move to next line without selecting
            nextLine();
        }

        async function nextLine() {
            // Save current line's trim data before navigating
            await saveCurrentLineTrimData();
            
            if (currentLine < totalLines) {
                currentLine++;
                loadLine(currentLine);
            }
        }

        async function prevLine() {
            // Save current line's trim data before navigating
            await saveCurrentLineTrimData();
            
            if (currentLine > 1) {
                currentLine--;
                loadLine(currentLine);
            }
        }

        async function saveCurrentLineTrimData() {
            // Save trim data for currently selected video on this line
            const videoName = selections[currentLine];
            if (videoName && trimData[currentLine]?.[videoName]) {
                await saveTrimData(currentLine, videoName);
            }
        }

        async function generateVideo() {
            const selectedCount = Object.keys(selections).length;
            
            if (selectedCount === 0) {
                alert('Please select at least one take!');
                return;
            }

            if (selectedCount < totalLines) {
                const confirm = window.confirm(
                    `You've only selected ${selectedCount} out of ${totalLines} lines.\n\n` +
                    `Do you want to generate the video with just these ${selectedCount} segments?\n\n` +
                    `(Click Cancel to continue selecting more takes)`
                );
                if (!confirm) return;
            }

            // Save current line's trim data before generating
            await saveCurrentLineTrimData();

            document.getElementById('content').innerHTML = `
                <div class="loading">
                    <div class="spinner"></div>
                    <p>Generating your video... This may take a few minutes.</p>
                    <p style="color: #666; margin-top: 10px;">Processing ${selectedCount} segment${selectedCount > 1 ? 's' : ''}...</p>
                </div>
            `;

            try {
                await fetch('/api/generate', { method: 'POST' });
                
                // Poll for completion
                checkStatus();
            } catch (error) {
                document.getElementById('content').innerHTML = `
                    <div class="status error">
                        Error generating video: ${error.message}
                    </div>
                `;
            }
        }

        async function checkStatus() {
            const response = await fetch('/api/status');
            const data = await response.json();
            
            if (data.processing) {
                setTimeout(checkStatus, 2000);
            } else {
                document.getElementById('content').innerHTML = `
                    <div class="status success">
                        <span class="icon-small">‚úÖ</span> Video generated successfully!
                        <br><br>
                        <strong>final_script_video_ui.mp4</strong> has been created in your project folder.
                    </div>
                    <div class="controls">
                        <button class="btn-generate" onclick="location.reload()">
                            <span class="icon-small">üîÑ</span> Start Over
                        </button>
                    </div>
                `;
            }
        }

        async function saveSession() {
            if (Object.keys(selections).length === 0) {
                alert('No selections to save yet!');
                return;
            }

            try {
                const response = await fetch('/api/save_session', { method: 'POST' });
                const data = await response.json();
                
                if (data.success) {
                    alert(`‚úÖ Session saved!\n\n${data.message}\n\nYou have ${Object.keys(selections).length} selection(s) saved.`);
                } else {
                    alert('Error saving session: ' + (data.error || 'Unknown error'));
                }
            } catch (error) {
                alert('Error saving session: ' + error.message);
            }
        }

        // Trim controls functionality
        let dragState = null;

        function initTrimControls(cardId, lineNum, videoName) {
            const video = document.getElementById(`video-${cardId}`);
            const duration = video.duration;
            
            // Initialize trim data if not exists
            if (!trimData[lineNum]) trimData[lineNum] = {};
            if (!trimData[lineNum][videoName]) {
                trimData[lineNum][videoName] = { start: 0, end: duration };
            }
            
            updateTrimDisplay(cardId, lineNum, videoName);
            
            // Generate waveform when video is selected
            const card = document.getElementById(cardId);
            if (card.classList.contains('selected')) {
                generateWaveform(cardId);
            }
        }

        async function generateWaveform(cardId) {
            const video = document.getElementById(`video-${cardId}`);
            const canvas = document.getElementById(`waveform-${cardId}`);
            if (!canvas || !video) return;
            
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth * 2; // Retina display support
            canvas.height = canvas.offsetHeight * 2;
            ctx.scale(2, 2);
            
            const displayWidth = canvas.width / 2;
            const displayHeight = canvas.height / 2;
            
            try {
                // Create audio context
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Fetch audio data
                const response = await fetch(video.src);
                const arrayBuffer = await response.arrayBuffer();
                const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                
                // Get audio data
                const rawData = audioBuffer.getChannelData(0);
                const samples = 300; // Number of bars to display
                const blockSize = Math.floor(rawData.length / samples);
                const filteredData = [];
                
                for (let i = 0; i < samples; i++) {
                    let blockStart = blockSize * i;
                    let sum = 0;
                    for (let j = 0; j < blockSize; j++) {
                        sum += Math.abs(rawData[blockStart + j]);
                    }
                    filteredData.push(sum / blockSize);
                }
                
                // Normalize data
                const multiplier = Math.pow(Math.max(...filteredData), -1);
                const normalizedData = filteredData.map(n => n * multiplier);
                
                // Draw waveform
                const barWidth = displayWidth / samples;
                const barGap = 1;
                
                ctx.clearRect(0, 0, displayWidth, displayHeight);
                
                normalizedData.forEach((value, i) => {
                    const barHeight = value * displayHeight * 0.85;
                    const x = i * barWidth;
                    const y = (displayHeight - barHeight) / 2;
                    
                    // Beautiful gradient from purple to pink
                    const gradient = ctx.createLinearGradient(0, y, 0, y + barHeight);
                    gradient.addColorStop(0, '#667eea');
                    gradient.addColorStop(0.5, '#764ba2');
                    gradient.addColorStop(1, '#ec4899');
                    
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, Math.max(barWidth - barGap, 1), barHeight);
                });
                
                audioContext.close();
            } catch (error) {
                console.error('Error generating waveform:', error);
                // Draw simple placeholder bars if waveform fails
                ctx.fillStyle = '#667eea';
                for (let i = 0; i < 80; i++) {
                    const x = (i * displayWidth) / 80;
                    const height = Math.random() * displayHeight * 0.6 + displayHeight * 0.2;
                    const y = (displayHeight - height) / 2;
                    ctx.fillRect(x, y, Math.max((displayWidth / 80) - 2, 1), height);
                }
            }
        }

        function startDrag(event, cardId, markerType) {
            event.stopPropagation();
            const timeline = document.getElementById(`timeline-${cardId}`);
            const rect = timeline.getBoundingClientRect();
            
            dragState = {
                cardId,
                markerType,
                timelineRect: rect,
                timelineWidth: rect.width
            };
            
            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', endDrag);
        }

        function onDrag(event) {
            if (!dragState) return;
            
            const { cardId, markerType, timelineRect, timelineWidth } = dragState;
            const video = document.getElementById(`video-${cardId}`);
            const duration = video.duration;
            
            // Calculate position relative to timeline
            let x = event.clientX - timelineRect.left;
            x = Math.max(0, Math.min(x, timelineWidth));
            
            const percent = x / timelineWidth;
            const time = percent * duration;
            
            // Get line and video info from card
            const matches = cardId.match(/card-(\d+)-(\d+)/);
            if (!matches) return;
            
            const lineNum = parseInt(matches[1]);
            const videoIndex = parseInt(matches[2]);
            
            // Get video name from the card
            const card = document.getElementById(cardId);
            const videoNameEl = card.querySelector('.video-name');
            const videoName = videoNameEl.textContent;
            
            if (!trimData[lineNum]) trimData[lineNum] = {};
            if (!trimData[lineNum][videoName]) {
                trimData[lineNum][videoName] = { start: 0, end: duration };
            }
            
            const trim = trimData[lineNum][videoName];
            
            if (markerType === 'start') {
                trim.start = Math.min(time, trim.end - 0.1);
            } else {
                trim.end = Math.max(time, trim.start + 0.1);
            }
            
            updateTrimDisplay(cardId, lineNum, videoName);
            
            // Update video current time to show trim
            video.currentTime = markerType === 'start' ? trim.start : trim.end;
        }

        function endDrag() {
            if (dragState) {
                // Save trim data to server when drag ends
                const { cardId } = dragState;
                const matches = cardId.match(/card-(\d+)-(\d+)/);
                if (matches) {
                    const lineNum = parseInt(matches[1]);
                    const card = document.getElementById(cardId);
                    const videoNameEl = card.querySelector('.video-name');
                    const videoName = videoNameEl.textContent;
                    saveTrimData(lineNum, videoName);
                }
            }
            
            dragState = null;
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', endDrag);
        }

        function updateTrimDisplay(cardId, lineNum, videoName) {
            const video = document.getElementById(`video-${cardId}`);
            const duration = video.duration;
            const trim = trimData[lineNum]?.[videoName] || { start: 0, end: duration };
            
            const startPercent = (trim.start / duration) * 100;
            const endPercent = (trim.end / duration) * 100;
            
            // Update markers
            const startMarker = document.getElementById(`start-${cardId}`);
            const endMarker = document.getElementById(`end-${cardId}`);
            const fill = document.getElementById(`fill-${cardId}`);
            
            if (startMarker) startMarker.style.left = `${startPercent}%`;
            if (endMarker) endMarker.style.left = `${endPercent}%`;
            if (fill) {
                fill.style.left = `${startPercent}%`;
                fill.style.width = `${endPercent - startPercent}%`;
            }
            
            // Update time display
            const timeDisplay = document.getElementById(`time-${cardId}`);
            if (timeDisplay) {
                timeDisplay.innerHTML = `
                    <span>Start: <strong>${trim.start.toFixed(2)}s</strong></span>
                    <span>Duration: <strong>${(trim.end - trim.start).toFixed(2)}s</strong></span>
                    <span>End: <strong>${trim.end.toFixed(2)}s</strong></span>
                `;
            }
        }

        function adjustTrim(cardId, marker, amount) {
            // Get line and video info
            const matches = cardId.match(/card-(\d+)-(\d+)/);
            if (!matches) return;
            
            const lineNum = parseInt(matches[1]);
            const card = document.getElementById(cardId);
            const videoNameEl = card.querySelector('.video-name');
            const videoName = videoNameEl.textContent;
            const video = document.getElementById(`video-${cardId}`);
            const duration = video.duration;
            
            if (!trimData[lineNum]?.[videoName]) return;
            
            const trim = trimData[lineNum][videoName];
            
            if (marker === 'start') {
                trim.start = Math.max(0, Math.min(trim.start + amount, trim.end - 0.1));
                video.currentTime = trim.start;
            } else {
                trim.end = Math.min(duration, Math.max(trim.end + amount, trim.start + 0.1));
                video.currentTime = trim.end;
            }
            
            updateTrimDisplay(cardId, lineNum, videoName);
            saveTrimData(lineNum, videoName);  // Save to server
        }

        function playTrimmed(cardId) {
            const video = document.getElementById(`video-${cardId}`);
            const matches = cardId.match(/card-(\d+)-(\d+)/);
            if (!matches) return;
            
            const lineNum = parseInt(matches[1]);
            const card = document.getElementById(cardId);
            const videoNameEl = card.querySelector('.video-name');
            const videoName = videoNameEl.textContent;
            
            const trim = trimData[lineNum]?.[videoName];
            if (!trim) return;
            
            // Set video to start position and play
            video.currentTime = trim.start;
            video.play();
            
            // Stop at end position
            const checkTime = setInterval(() => {
                if (video.currentTime >= trim.end) {
                    video.pause();
                    clearInterval(checkTime);
                }
            }, 100);
            
            // Clear interval if video is paused manually
            video.addEventListener('pause', () => clearInterval(checkTime), { once: true });
        }

        function resetTrim(cardId, lineNum, videoName) {
            const video = document.getElementById(`video-${cardId}`);
            const duration = video.duration;
            
            // Reset trim to full video
            if (!trimData[lineNum]) trimData[lineNum] = {};
            trimData[lineNum][videoName] = { start: 0, end: duration };
            
            updateTrimDisplay(cardId, lineNum, videoName);
            video.currentTime = 0;
        }

        async function selectTake(lineNum, videoName, card) {
            selections[lineNum] = videoName;
            
            // Update UI
            document.querySelectorAll('.take-card').forEach(c => {
                c.classList.remove('selected');
                c.classList.remove('hovered-for-io'); // Also remove hover indicator
            });
            card.classList.add('selected');
            card.classList.remove('hovered-for-io'); // Ensure hover class is removed from selected card
            
            // Generate waveform for the selected card
            const cardId = card.id;
            setTimeout(() => generateWaveform(cardId), 100);
            
            // Get trim data for this selection
            const trimInfo = trimData[lineNum]?.[videoName];
            
            // Save selection with trim data
            await fetch('/api/select', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ 
                    line_number: lineNum, 
                    video_name: videoName,
                    trim: trimInfo 
                })
            });
            
            updateProgress();
        }

        async function saveTrimData(lineNum, videoName) {
            // Save updated trim data to server
            const trimInfo = trimData[lineNum]?.[videoName];
            if (trimInfo && selections[lineNum] === videoName) {
                await fetch('/api/select', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ 
                        line_number: lineNum, 
                        video_name: videoName,
                        trim: trimInfo 
                    })
                });
            }
        }

        // Hover preview functionality
        function startHoverPreview(cardId) {
            hoveredCardId = cardId; // Track which card is being hovered
            
            // Add visual indicator for hover
            const card = document.getElementById(cardId);
            if (card && !card.classList.contains('selected')) {
                card.classList.add('hovered-for-io');
            }
            
            const video = document.getElementById(`video-${cardId}`);
            if (video && video.readyState >= 2) {
                video.play().catch(() => {}); // Ignore errors if play fails
            }
        }

        function stopHoverPreview(cardId) {
            if (hoveredCardId === cardId) {
                hoveredCardId = null; // Clear hover tracking
            }
            
            // Remove visual indicator
            const card = document.getElementById(cardId);
            if (card) {
                card.classList.remove('hovered-for-io');
            }
            
            const video = document.getElementById(`video-${cardId}`);
            const indicator = document.getElementById(`hover-${cardId}`);
            if (video) {
                video.pause();
            }
            if (indicator) {
                indicator.style.width = '0';
            }
        }

        function updateHoverPreview(event, cardId) {
            const video = document.getElementById(`video-${cardId}`);
            const indicator = document.getElementById(`hover-${cardId}`);
            const container = event.currentTarget;
            
            if (!video || !video.duration) return;
            
            const rect = container.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const percent = x / rect.width;
            const time = percent * video.duration;
            
            // Store current hover position for this video
            hoverPositions[cardId] = time;
            
            // Update video position
            video.currentTime = time;
            
            // Update hover indicator
            if (indicator) {
                indicator.style.width = `${percent * 100}%`;
            }
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', async (event) => {
            const key = event.key.toLowerCase();
            
            // Handle Enter key (works globally)
            if (key === 'enter') {
                event.preventDefault();
                nextLine();
                return;
            }
            
            // For 'i' and 'o' keys, prioritize hovered card over selected card
            if (key === 'i' || key === 'o') {
                let cardId = hoveredCardId; // Try hovered card first
                let shouldAutoSelect = false;
                
                // If no hovered card, fall back to selected card
                if (!cardId) {
                    const selectedCard = document.querySelector('.take-card.selected');
                    if (selectedCard) {
                        cardId = selectedCard.id;
                    }
                } else {
                    // If hovering over a card, check if it's not already selected
                    const hoveredCard = document.getElementById(cardId);
                    if (hoveredCard && !hoveredCard.classList.contains('selected')) {
                        shouldAutoSelect = true;
                    }
                }
                
                if (!cardId) return;
                
                const matches = cardId.match(/card-(\d+)-(\d+)/);
                if (!matches) return;
                
                const lineNum = parseInt(matches[1]);
                const card = document.getElementById(cardId);
                const videoNameEl = card.querySelector('.video-name');
                const videoName = videoNameEl.textContent;
                const video = document.getElementById(`video-${cardId}`);
                
                if (!video) return;
                
                // Auto-select the card if we're hovering over it
                if (shouldAutoSelect) {
                    await selectTake(lineNum, videoName, card);
                }
                
                // Initialize trim data if it doesn't exist
                if (!trimData[lineNum]) trimData[lineNum] = {};
                if (!trimData[lineNum][videoName]) {
                    const duration = video.duration || 0;
                    trimData[lineNum][videoName] = { start: 0, end: duration };
                }
                
                event.preventDefault();
                
                if (key === 'i') {
                    // Set In point (start of trim) - use hover position if available
                    const time = hoverPositions[cardId] !== undefined ? hoverPositions[cardId] : video.currentTime;
                    trimData[lineNum][videoName].start = Math.min(time, trimData[lineNum][videoName].end - 0.1);
                    updateTrimDisplay(cardId, lineNum, videoName);
                    saveTrimData(lineNum, videoName);
                    console.log(`In point set to ${time.toFixed(2)}s`);
                } else if (key === 'o') {
                    // Set Out point (end of trim) - use video playback position
                    trimData[lineNum][videoName].end = Math.max(video.currentTime, trimData[lineNum][videoName].start + 0.1);
                    updateTrimDisplay(cardId, lineNum, videoName);
                    saveTrimData(lineNum, videoName);
                    console.log(`Out point set to ${video.currentTime.toFixed(2)}s`);
                }
                
                return;
            }
            
            // For spacebar, only work on selected card
            if (key === ' ') {
                const selectedCard = document.querySelector('.take-card.selected');
                if (!selectedCard) return;
                
                const cardId = selectedCard.id;
                const video = document.getElementById(`video-${cardId}`);
                
                if (video) {
                    event.preventDefault(); // Prevent page scroll
                    if (video.paused) {
                        video.play();
                    } else {
                        video.pause();
                    }
                }
            }
        });

        // Initialize on page load
        initialize();
    </script>
</body>
</html>

